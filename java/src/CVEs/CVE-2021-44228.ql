/**
 * @name Log4Shell
 * @description JNDI Injection in Log4J library
 * @kind path-problem
 * @problem.severity error
 * @precision high
 * @id seclab/log4shell
 * @tags security
 */

import java
import semmle.code.java.dataflow.TaintTracking
import semmle.code.java.security.JndiInjection
import DataFlow::PathGraph

class Log4ShellConfig extends TaintTracking::Configuration {
  Log4ShellConfig() { this = "Log4ShellConfig" }

  override int fieldFlowBranchLimit() { result = 9 }

  override predicate isSource(DataFlow::Node source) {
    exists(Method m, Parameter p |
      m.getParameter(0) = p and
      p = source.asParameter() and
      m.getASourceOverriddenMethod().hasQualifiedName("org.apache.logging.log4j", "Logger", "info") and
      p.getType().(RefType).hasQualifiedName("java.lang", "CharSequence") and
      m.getNumberOfParameters() = 1
    )
  }

  override predicate isSink(DataFlow::Node sink) { sink instanceof JndiInjectionSink }

  override predicate isSanitizer(DataFlow::Node n) {
    exists(string s | n.getLocation().getFile().getBaseName() = s |
      s.matches("%Appender.java") and not s = "AbstractOutputStreamAppender.java"
      or
      s.matches("%Layout.java") and not s = "PatternLayout.java"
    )
    or
    exists(string s | n.getLocation().getFile().getRelativePath() = s | s.matches("%/src/test/%"))
  }
}

from Log4ShellConfig conf, DataFlow::PathNode source, DataFlow::PathNode sink
where conf.hasFlowPath(source, sink)
select sink, source, sink, "log4shell"
